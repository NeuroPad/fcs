async def get_answer(self, question: str) -> ExtendedGraphRAGResponse:
        # Initialize the embedding model
        #embed_model = OpenAIEmbedding(model_name="text-embedding-ada-002")
        embed_model = HuggingFaceEmbedding(model_name="BAAI/bge-small-en-v1.5")
        # Initialize VectorContextRetriever
        vector_retriever = VectorContextRetriever(
            graph_store=self.neo_store,
            embed_model=embed_model,
            similarity_top_k=12,
            path_depth=3,
            include_text=True,
        )

        # Append additional instructions to the query
        qa_tmpl_str = (
            "Context information is below.\n"
            "---------------------\n"
            "{context_str}\n"
            "---------------------\n"
            "Given the context information and not prior knowledge, "
            "answer the query. If there are images in the context_str that are relevant to your answer, "
            "list them after your response in this exact format:\n\n"
            "markdown/[document_name]_artifacts/[image_filename]\n"
            "also list the source or sources used in this exact format, you can see the source in the file_path in the context\n\n"
            "source: markdown/[document_name].md\n\n"
            "Example:\n"
            "image(s): markdown/Adebisi_Joseph_CV-with-refs_artifacts/image_000001_cb38f16cd497655883fbf4717e084dc6d4206c0258e92b225301d8b3cf8bb6a4.png\n"
            "source(s): markdown/Adebisi_Joseph_CV-with-refs.md\n\n"
            "make sure to not repeat a source or image and always include images and source where they are available"
            "Query: {query_str}\n"
            "Answer: "
        )
        qa_tmpl = PromptTemplate(qa_tmpl_str)

        # Create Query Engine
        query_engine = RetrieverQueryEngine.from_args(vector_retriever, text_qa_template=qa_tmpl)

        # Perform a query with the modified question
        response = query_engine.query(question)

        # Extract the response text
        full_response = response.response

        # Helper functions to extract information
        def extract_images(text: str) -> List[str]:
            image_pattern = r'markdown/[^,\s]+\.png'
            matches = re.findall(image_pattern, text)
            return list(dict.fromkeys(matches))  # Remove duplicates while preserving order

        def extract_sources(text: str) -> List[str]:
            source_pattern = r'markdown/[^,\s]+\.md'
            matches = re.findall(source_pattern, text)
            return list(dict.fromkeys(matches))  # Remove duplicates while preserving order

        def clean_answer(text: str) -> str:
            # Remove the image and source lines from the answer
            answer_lines = []
            for line in text.split('\n'):
                if not any(marker in line.lower() for marker in ['image(s):', 'source(s):']):
                    answer_lines.append(line)
            return '\n'.join(answer_lines).strip()

        # Extract components
        images = extract_images(full_response)
        sources = extract_sources(full_response)
        clean_response = clean_answer(full_response)
        logger.debug(f"Processed result: {response}")
        # Ensure images and sources are included if they exist in the context
        # if not images:
        #     images = self.extract_images_from_context(response.context_str)
        # if not sources:
        #     sources = self.extract_sources_from_context(response.context_str)

        # Create and return ExtendedGraphRAGResponse
        result = ExtendedGraphRAGResponse(
            answer=clean_response,
            images=images,
            sources=sources
        )

        # Log the result
        print(response)
        print(result)
        logger.info("Response processed successfully")
        logger.debug(f"Processed result: {result}")

        return result

    def extract_images_from_context(self, context_str: str) -> List[str]:
        image_pattern = r'markdown/[^,\s]+\.png'
        matches = re.findall(image_pattern, context_str)
        return list(dict.fromkeys(matches))  # Remove duplicates while preserving order

    def extract_sources_from_context(self, context_str: str) -> List[str]:
        source_pattern = r'markdown/[^,\s]+\.md'
        matches = re.findall(source_pattern, context_str)
        return list(dict.fromkeys(matches))  # Remove duplicates while preserving order